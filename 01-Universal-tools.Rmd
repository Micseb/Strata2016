---
title: "R with Big Data 1: Universal Tools"
author: "Garrett Grolemund and Nathan Stephens"
date: "September 27, 2016"
output: html_notebook
---

```{r setup, include = FALSE}
library(dplyr)
library(nycflights13)
library(EDAWR)
```

These are the class notes (Part 1 of 4) for *R for Big Data*, a workshop taught at *Strata + Hadoop World 2016 NYC*.

# Notebook logistics

***

**Exercise 1**: *Read through this section and try out the features described below. Stop when you get to the first horizontal rule (`***`)*

These notes are an R Markdown Notebook that contains both text and code.

* Add a new chunk of code by clicking the *Insert Chunk* button on the toolbar or by pressing *Cmd+Option+I*.

* Execute a chunk by clicking the *Run* button within the chunk or by placing your cursor inside it and pressing *Cmd+Shift+Enter*. The results will appear beneath the code. To see how this works, try executing the chunk below:

```{r}
paste("Hello", "world!")
```

When you save the notebook, an HTML file containing the code and output will be saved alongside it (click the *Preview* button or press *Cmd+Shift+K* to preview the HTML file).

Use Markdown syntax to format text for the HTML output. Click *Help > Markdown Quick Reference* in the toolbar to open a guide in the help pane.

***

# dplyr

The dplyr package provides a universal set of tools for data manipulation. You can use these tools to manipulate from R data that is stored in

* R
* databases
* Spark

and other places. dplyr is written to be a front end with extensible backends. For more information, see [Adding a new SQL backend](https://cran.r-project.org/web/packages/dplyr/vignettes/new-sql-backend.html).

Dplyr contains ~18 functions that together form a complete grammar of data manipulation. These functions can loosely be categorized into:

## Single table verbs

Single table verbs take a single data frame, reference, or tibble and return a single data frame, reference, or tibble. 

* `select` - returns a subset of columns from the data.

* `mutate` - returns the data with one or more new columns computed from the data.

* `filter` - return only the rows of the data that meet one or more logical conditions.

* `arrange` - returns the data with the rows reordered by increasing (or descending with `desc()`) values of one or more variables.

* `summarise` - returns a new data set that summarises the information in the original data set.

* `group_by` - "splits" the data into sub-groups based on common values of a variable (or common combinations of the values of two or more variables). dplyr functions will treat each group within a grouped data set separately, which is very useful with `summarise`.


***

**Exercise 2**: *The `iris` data set contains biometric measurements of three species of flower. In the code chunk below,* 

1. *Group iris by Species*
2. *For each group, return:*
    + *`avg_width` = mean Petal.Width* 
    + *`avg_length` = mean Petal.Length*
3. *For each row, calculate `diff = avg_length - avg_width`* 
4. *Return the row whose diff == the max diff*
5. *Return the columns above*

```{r}
# To inspect the raw data before you begin,
# remove the hash tag below and run the chunk
# View(iris)
```


***

## The pipe operator

A pipe is a sequence of functions where each function passes its output to the next function to use as input. Pipes are common with dplyr, as dplyr functions are written to be composable. 

The easiest way to write a pipe in R is with the ` %>% ` operator from the magrittr package (imported with the dplyr package). ` %>% ` passes the output of the expression on the left-hand side of the pipe as the first argument of the expression on the right hand side of the pipe, e.g. these two pieces of code do the same thing.

```{r}
filter(iris, Sepal.Length == max(Sepal.Length))
```

```{r}
iris %>% filter(Sepal.Length == max(Sepal.Length))
```

Type ` %>% ` with the keyboard shortcut *Cmd+Shift+M*.

***

**Exercise 3**: *You can use ` %>% ` to string many functions together into a long pipe. Use ` %>% ` to turn the code below (from Exercise 3) into a single long pipe.

```{r}
iris1 <- group_by(iris, Species)
iris2 <- summarise(iris1, avg_width = mean(Petal.Width), avg_length = mean(Petal.Length))
iris3 <- mutate(iris2, diff = avg_length - avg_width)
iris4 <- filter(iris3, diff == max(diff))
select(iris4, -diff)
```

***

## Two table verbs

Two table verbs take two data frames, references, or tibbles and return a single data frame, reference, or tibble. 

* `bind_rows` - adds one data set beneath another as new rows

* `union` - returns every row that appears in at least one of the data sets, removing duplicate rows

* `intersect` - returns the rows that appear in both data sets

* `setdiff` - returns the rows that appear in the first data set, but not the second

* `bind_cols` - adds one data set beside the other as new columns

**Mutating joins** add new variables to one data set from matching rows in a second data set. dplyr has 4 mutating joins. The joins differ in the information they do not return.

* `left_join` - Drops rows from the *______* data set that do not match rows in the first.

* `right_join` - Drops rows from the *______* data set that do not match rows in the second.

* `inner_join` - Drops rows from *______* data sets that do not match rows in the other data set.

* `full_join` - Drops rows from *______* data set.

**Filtering joins** return rows from the first data set based on whether or not they match rows in the second data set.

* `semi_join` - Returns rows from first data set that *______* rows in the second data set.

* `anti_join` - Returns rows from first data set that *______* rows in the second data set.


***

**Exercise 4**: *The code below creates two simple data sets that can be joined together. Run the chunks and examine the data sets. Then use the following chunk to test out different types of joins with the data sets and to compare their results. Use what you discover to finish the definition of each join above in your own words.*

```{r}
(band <- 
  data_frame(name = c("Mick", "John", "Paul"),
             band = c("Stones", "Beatles", "Beatles")))
```

```{r}
(instrument <- 
  data_frame(name = c("John", "Paul", "Keith"),
             plays = c("guitar", "bass", "guitar")))
```

```{r}
# join
band %>% right_join(instrument, by = "name")
```

***

# Airlines Project

The nycflights13 package contains records of every flight that departed from La Guardia (`LGA`), JFK (`JFK`) and Newark (`EWR`) airports in 2013.

The data is split into five related data sets:

1. `flights` - arrival and departure delay information by flight (the main data set)
2. `airlines` - airlines names by code
3. `airports` - airport names by code
4. `planes` - plane metadata
5. `weather` - hourly weather data

![](nycflights.png)


**Exercise 5**: *Use the chunk below to determine which airline has the newest planes (assigned to the NYC area).*

```{r}
flights %>%
  # selects distinct combinations of carrier and tailnum
  distinct(carrier, tailnum) # %>%
  # join to planes to get the year manufactured variable
  # (which column should you join on?)
  # __________________________ %>%
  # group by carrier (e.g. the airline)
  # __________________________ %>%
  # calculate by carrier:
  #   1. avg - the mean year (with na.rm = TRUE) 
  #   2. n - the total number of planes
  #   3. nas - the number of planes with unknown year (year == NA)
  # __________________________, n = n(), nas = sum(is.na(year))) %>%
  # join to airlines to get the full airline name 
  # (which column should you join on?)
  # __________________________ %>%
  # select just the name, avg, n, and nas variables in that order
  # __________________________ %>%
  # order the results by avg with the newest planes at the top
  # __________________________ %>%
```

